# RocksDB Write Buffer 최적화: 성능과 메모리 사용량의 트레이드오프 분석

**컴퓨터공학과 4학년**  
**발표 시간: 15분**

---

## 1. 연구 동기 및 배경 (2분)

### 🎯 연구 동기
- **RocksDB**는 고성능 Key-Value 스토리지 엔진
- **Write Buffer**는 메모리 내 쓰기 성능의 핵심 구성요소
- 적절한 설정 없이는 **성능 저하** 및 **메모리 낭비** 발생

### 📚 기존 이론
- **Write Buffer Size ↑** → **쓰기 성능 ↑**, **메모리 사용량 ↑**
- **Buffer 개수 ↑** → **병렬 처리 ↑**, **컴팩션 복잡도 ↑**
- **Merge 임계값 ↑** → **컴팩션 지연**, **메모리 압박**

### ❓ 연구 질문
1. Write Buffer Size가 성능에 미치는 실제 영향은?
2. 메모리 사용량과 성능 간의 최적 균형점은?
3. Buffer 설정 조합이 성능에 미치는 영향은?

---

## 2. 가설 및 실험 설계 (3분)

### 🔬 연구 가설
**H1**: "Write Buffer 크기가 클수록 성능이 향상될 것이다"  
**H2**: "메모리 사용량과 성능 간 선형 관계가 있을 것이다"  
**H3**: "최적 설정 조합이 존재할 것이다"

### 🧪 실험 설계

#### 독립 변수
- **write_buffer_size**: 16MB, 64MB, 128MB, 256MB, 512MB
- **max_write_buffer_number**: 2, 4, 6
- **min_write_buffer_number_to_merge**: 1, 2, 3

#### 종속 변수
- **평균 지연시간** (μs)
- **처리량** (ops/sec)
- **메모리 사용량**

#### 벤치마크
- **fillrandom**: 순차적 랜덤 쓰기
- **readrandom**: 랜덤 읽기
- **overwrite**: 기존 데이터 덮어쓰기

### 📊 실험 조건
- **데이터 크기**: 1,000,000 키
- **값 크기**: 1KB
- **반복 횟수**: 3회 (통계적 유의성)
- **총 실험**: 69회

---

## 3. 실험 결과 (5분)

### 📈 주요 성능 지표

#### Write Buffer Size별 평균 지연시간 (기본 설정)

| Buffer Size | fillrandom | readrandom | overwrite |
|-------------|------------|------------|-----------|
| 16MB        | 2.766μs    | 2.669μs    | 2.755μs   |
| 64MB        | 2.751μs    | 2.673μs    | 2.633μs   |
| 128MB       | 2.652μs    | 2.702μs    | 2.698μs   |
| 256MB       | **2.608μs** | 2.678μs    | **2.585μs** |
| 512MB       | 122.333μs  | **2.664μs** | 111.000μs |

### 🏆 최적 성능 설정
- **fillrandom**: 256MB (97.9% 성능 개선)
- **readrandom**: 512MB (1.4% 성능 개선)  
- **overwrite**: 256MB (97.7% 성능 개선)

### ⚠️ 성능 이상 현상 발견

#### 512MB에서의 급격한 성능 저하
- **fillrandom**: 2.6μs → 122.3μs (47배 증가)
- **overwrite**: 2.6μs → 111.0μs (43배 증가)
- **원인**: 메모리 부족으로 인한 스왑 발생 추정

#### Buffer 설정 조합의 영향 (128MB 기준)

| max_buffers | min_merge | 평균 지연시간 | 성능 비교 |
|-------------|-----------|---------------|-----------|
| 2           | 1         | 2.652μs       | 기준      |
| 2           | 2         | 2.615μs       | 1.4% 개선 |
| 2           | 3         | 2.558μs       | 3.5% 개선 |
| 4           | 3         | **97.500μs**  | **3,577% 저하** |
| 6           | 3         | **110.917μs** | **4,082% 저하** |

---

## 4. 결과 분석 및 해석 (4분)

### 🔍 가설 검증 결과

#### H1: "Write Buffer 크기 ↑ → 성능 ↑" 
**❌ 기각** - 512MB에서 급격한 성능 저하 발생

#### H2: "메모리 사용량과 성능 간 선형 관계"
**❌ 기각** - 비선형적 관계, 임계점 존재

#### H3: "최적 설정 조합 존재"
**✅ 채택** - 256MB가 대부분 워크로드에서 최적

### 🧠 원인 분석

#### 1. 512MB에서의 성능 저하
- **메모리 압박**: 시스템 메모리 부족
- **스왑 발생**: 디스크 I/O로 인한 지연
- **컴팩션 지연**: 큰 버퍼로 인한 처리 복잡도 증가

#### 2. min_merge=3의 위험성
- **버퍼 누적**: 과도한 메모리 사용
- **컴팩션 병목**: 대량 데이터 처리 지연
- **I/O 폭증**: 동시 컴팩션 작업 증가

### 💡 이론과 실제의 차이

#### 예상 vs 실제
- **예상**: 선형적 성능 향상
- **실제**: 임계점 이후 급격한 성능 저하
- **핵심**: 시스템 리소스 한계가 성능 결정

#### 최적화 포인트
- **Sweet Spot**: 128MB~256MB
- **위험 구간**: 512MB 이상
- **안전 설정**: max_buffers≤4, min_merge≤2

---

## 5. 결론 및 향후 과제 (1분)

### 🎯 핵심 인사이트

1. **"더 크다 ≠ 더 좋다"** - 적절한 균형이 중요
2. **임계점 존재** - 256MB가 최적 성능 구간
3. **설정 조합의 중요성** - 잘못된 조합은 치명적

### 📋 실무 적용 가이드라인

#### 권장 설정
```
write_buffer_size = 128MB~256MB
max_write_buffer_number = 2~4  
min_write_buffer_number_to_merge = 1~2
```

#### 워크로드별 최적화
- **쓰기 집약적**: 128MB, max_buffers=4
- **읽기 집약적**: 64MB~128MB, max_buffers=2  
- **혼합 워크로드**: 128MB, max_buffers=2

### 🚀 향후 연구 과제

1. **다양한 하드웨어 환경**에서의 검증
2. **실제 워크로드 패턴** 적용 실험
3. **동적 튜닝 알고리즘** 개발
4. **메모리 압박 상황**에서의 최적화 전략

---

## Q&A

**감사합니다!**

---

### 📊 참고 자료

- **실험 데이터**: 69회 실험, 23개 설정 조합
- **성능 개선**: 최대 97.9% (fillrandom, 256MB)
- **위험 요소**: 512MB에서 4,000% 성능 저하
- **최적 구간**: 128MB~256MB (안정적 성능)

### 🔗 추가 정보
- 실험 코드: `run_write_buffer_experiment.sh`
- 분석 결과: `analysis_report.md`
- 시각화: `performance_analysis.png`, `detailed_analysis.png` 